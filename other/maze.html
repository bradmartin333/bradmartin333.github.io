<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Maze</title>
    <style>
        :root {
            --bg-color: #e0e7ff;
            --text-color: #000;
            --border-color: #000;
            --shadow-color: #000;
            --accent-color: #a3e635; /* Lime */
            --accent-secondary: #f472b6; /* Pink */
            --border-width: 3px;
            --shadow-offset: 6px;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: var(--bg-color);
            font-family: 'Courier New', Courier, monospace;
            color: var(--text-color);
            transition: background-color 0.5s;
        }

        /* disable overscroll / pull-to-refresh for browsers that support it */
        html, body {
            overscroll-behavior-y: none;
            -ms-touch-action: pan-y;
            touch-action: pan-y;
        }

        h1 {
            font-weight: 900;
            text-transform: uppercase;
            margin-bottom: 20px;
            text-shadow: 2px 2px 0px var(--shadow-color);
            font-size: 2rem;
            text-align: center;
        }

        #game-container {
            border: var(--border-width) solid var(--border-color);
            background-color: #fff;
            padding: 20px;
            box-shadow: var(--shadow-offset) var(--shadow-offset) 0px 0px var(--shadow-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 90vw;
        }

        #maze {
            display: grid;
            grid-template-columns: repeat(10, 35px);
            grid-template-rows: repeat(10, 35px);
            border: var(--border-width) solid var(--border-color);
            background-color: #000;
            gap: 1px; /* Grid lines */
        }

        .cell {
            width: 35px;
            height: 35px;
            background-color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: default;
            transition: background-color 0.2s;
        }

        .wall {
            background-color: #000;
            background-image: repeating-linear-gradient(
                45deg,
                #000,
                #000 5px,
                #222 5px,
                #222 10px
            );
        }

        .path {
            background-color: #fff;
        }

        .start {
            background-color: var(--accent-color);
        }

        .end {
            background-color: var(--accent-secondary);
            position: relative;
        }
        
        .end::after {
            content: 'üèÅ';
            font-size: 20px;
        }

        #character {
            font-size: 24px;
            line-height: 1;
            user-select: none;
            filter: drop-shadow(2px 2px 0px rgba(0,0,0,0.2));
            transition: transform 0.1s;
        }

        #status-bar {
            margin-top: 20px;
            border: var(--border-width) solid var(--border-color);
            background-color: #fff;
            padding: 10px 15px;
            box-shadow: var(--shadow-offset) var(--shadow-offset) 0px 0px var(--shadow-color);
            font-weight: bold;
            min-width: 300px;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        #status-text {
            font-size: 1.1em;
            text-transform: uppercase;
        }
        
        #boredom-meter {
            font-size: 0.8em;
            color: #666;
        }

        #controls-hint {
            margin-top: 30px;
            font-size: 0.8rem;
            opacity: 0.7;
        }

        @keyframes wacky-spin {
            0% { transform: scale(1) rotate(0deg); filter: hue-rotate(0deg); }
            50% { transform: scale(1.5) rotate(180deg); filter: hue-rotate(180deg) invert(1); }
            100% { transform: scale(0) rotate(720deg); filter: hue-rotate(360deg) invert(0); opacity: 0; }
        }

        .wacky-exit {
            animation: wacky-spin 2s ease-in-out forwards;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <h1>The Maze</h1>
        <div id="maze"></div>
        
        <div id="status-bar">
            <div id="status-text">"Let's get this over with."</div>
            <div id="boredom-meter">Boredom: 0%</div>
        </div>

        <div id="controls-hint">Use ARROW KEYS or SWIPE to move.</div>
    </div>


    <script>
        const mazeElement = document.getElementById('maze');
        const statusText = document.getElementById('status-text');
        const boredomMeter = document.getElementById('boredom-meter');

        // 10x10 Grid
        let mazeMap = [
            [2, 0, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 0, 1, 1, 1, 1, 0, 1],
            [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 0, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 0, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 1, 1, 1, 0, 0],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 1]
        ];
        
        let endPos = { row: 8, col: 9 };
        mazeMap[endPos.row][endPos.col] = 3;

        let characterPos = { row: 0, col: 0 };
        let boredom = 0;
        let moves = 0;
        let lastMoveTime = Date.now();
        let gameActive = true;
        let lastState = '';
        let moveHistory = [];
        
        const emojis = {
            happy: "üòé",
            neutral: "üòê",
            bored: "üòí",
            tired: "ü•±",
            dead: "üíÄ"
        };

        const phrases = {
            happy: ["Too easy.", "Speed run!", "Watch me go.", "I am speed."],
            neutral: ["Just a maze.", "Left... Right...", "Another wall.", "Walking."],
            bored: ["Are we there yet?", "This is repetitive.", "I've seen this wall.", "Sigh."],
            tired: ["I need coffee.", "My legs hurt.", "Why is it so far?", "Zzz..."],
            dead: ["I live here now.", "Tell my family I love them.", "Eternal labyrinth.", "Game over man."]
        };

        function getBoredomState() {
            if (boredom < 20) return 'happy';
            if (boredom < 40) return 'neutral';
            if (boredom < 60) return 'bored';
            if (boredom < 80) return 'tired';
            return 'dead';
        }

        function updateStatus() {
            const state = getBoredomState();
            
            if (state !== lastState) {
                const phraseList = phrases[state];
                const randomPhrase = phraseList[Math.floor(Math.random() * phraseList.length)];
                statusText.textContent = `"${randomPhrase}"`;
                lastState = state;
                
                // Update Character Emoji
                const charEl = document.getElementById('character');
                if (charEl) charEl.textContent = emojis[state];
            }
            
            boredomMeter.textContent = `BOREDOM: ${Math.floor(boredom)}%`;
        }

        function triggerGameOver() {
            if (!gameActive) return;
            gameActive = false;
            document.body.classList.add('wacky-exit');
            statusText.textContent = "MAXIMUM BOREDOM REACHED!";
            setTimeout(() => {
                window.location.href = "https://en.wikipedia.org/wiki/Boredom";
            }, 2000);
        }

        function drawMaze() {
            mazeElement.innerHTML = '';
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;

                    const type = mazeMap[r][c];
                    if (type === 1) cell.classList.add('wall');
                    if (type === 0) cell.classList.add('path');
                    if (type === 2) cell.classList.add('start');
                    if (type === 3) cell.classList.add('end');

                    if (r === characterPos.row && c === characterPos.col) {
                        const char = document.createElement('div');
                        char.id = 'character';
                        char.textContent = emojis[getBoredomState()];
                        cell.appendChild(char);
                    }
                    
                    mazeElement.appendChild(cell);
                }
            }
        }

        function moveCharacter(dr, dc) {
            if (!gameActive) return;
            const newR = characterPos.row + dr;
            const newC = characterPos.col + dc;

            if (newR >= 0 && newR < 10 && newC >= 0 && newC < 10 && mazeMap[newR][newC] !== 1) {
                characterPos.row = newR;
                characterPos.col = newC;
                moves++;
                
                const posKey = `${newR},${newC}`;
                if (moveHistory.includes(posKey)) {
                    boredom += 3;
                } else {
                    boredom = Math.max(0, boredom - 1);
                }
                
                moveHistory.push(posKey);
                if (moveHistory.length > 10) moveHistory.shift();

                checkProximity();
                drawMaze();
                updateStatus();
                
                if (mazeMap[newR][newC] === 3) {
                    alert("You solved it! But the boredom remains.");
                    location.reload();
                }
            } else {
                boredom = Math.min(100, boredom + 10);
                updateStatus();
            }
            lastMoveTime = Date.now();
            if (boredom >= 100) triggerGameOver();
        }

        function checkProximity() {
            const dist = Math.abs(characterPos.row - endPos.row) + Math.abs(characterPos.col - endPos.col);
            
            if (dist <= 3) {
                shiftMaze();
            }
        }

        function isSolvable(map, start, end) {
            let q = [start];
            let visited = new Set();
            visited.add(`${start.row},${start.col}`);
            
            while(q.length > 0) {
                let curr = q.shift();
                if(curr.row === end.row && curr.col === end.col) return true;
                
                const dirs = [[0,1], [0,-1], [1,0], [-1,0]];
                for(let d of dirs) {
                    let nr = curr.row + d[0];
                    let nc = curr.col + d[1];
                    
                    if(nr >= 0 && nr < 10 && nc >= 0 && nc < 10 && 
                       map[nr][nc] !== 1 && !visited.has(`${nr},${nc}`)) {
                        visited.add(`${nr},${nc}`);
                        q.push({row: nr, col: nc});
                    }
                }
            }
            return false;
        }

        function getReachableCells(map, start) {
            let reachable = [];
            let q = [start];
            let visited = new Set();
            visited.add(`${start.row},${start.col}`);
            
            while(q.length > 0) {
                let curr = q.shift();
                reachable.push(curr);
                
                const dirs = [[0,1], [0,-1], [1,0], [-1,0]];
                for(let d of dirs) {
                    let nr = curr.row + d[0];
                    let nc = curr.col + d[1];
                    
                    if(nr >= 0 && nr < 10 && nc >= 0 && nc < 10 && 
                       map[nr][nc] !== 1 && !visited.has(`${nr},${nc}`)) {
                        visited.add(`${nr},${nc}`);
                        q.push({row: nr, col: nc});
                    }
                }
            }
            return reachable;
        }

        function shiftMaze() {
            // Create a deep copy to test changes
            let testMap = JSON.parse(JSON.stringify(mazeMap));
            let oldEndPos = { ...endPos };
            
            // 1. Move Exit
            testMap[oldEndPos.row][oldEndPos.col] = 0;
            
            // Get only reachable candidates
            let allReachable = getReachableCells(testMap, characterPos);
            let candidates = allReachable.filter(pos => {
                const d = Math.abs(pos.row - characterPos.row) + Math.abs(pos.col - characterPos.col);
                return d > 5;
            });
            
            let newEndPos = oldEndPos;
            if (candidates.length > 0) {
                const newExit = candidates[Math.floor(Math.random() * candidates.length)];
                newEndPos = { row: newExit.row, col: newExit.col };
                testMap[newEndPos.row][newEndPos.col] = 3;
            }
            
            // 2. Shuffle walls
            for(let i=0; i<5; i++) {
                let r = Math.floor(Math.random() * 10);
                let c = Math.floor(Math.random() * 10);
                
                if ((r !== characterPos.row || c !== characterPos.col) && 
                    (r !== newEndPos.row || c !== newEndPos.col) &&
                    (r !== 0 || c !== 0)) {
                        testMap[r][c] = testMap[r][c] === 1 ? 0 : 1;
                }
            }

            // 3. Validate Solvability
            if (isSolvable(testMap, characterPos, newEndPos)) {
                mazeMap = testMap;
                endPos = newEndPos;
                statusText.textContent = "\"Wait, did the exit just move?\"";
                boredom += 10;
            } else {
                // Fallback: Use current map (guaranteed reachable path exists to these candidates)
                mazeMap[endPos.row][endPos.col] = 0;
                
                // Recalculate candidates on current map to be safe
                let currentReachable = getReachableCells(mazeMap, characterPos);
                let safeCandidates = currentReachable.filter(pos => {
                    const d = Math.abs(pos.row - characterPos.row) + Math.abs(pos.col - characterPos.col);
                    return d > 5;
                });

                if (safeCandidates.length > 0) {
                     const newExit = safeCandidates[Math.floor(Math.random() * safeCandidates.length)];
                     endPos = { row: newExit.row, col: newExit.col };
                     mazeMap[endPos.row][endPos.col] = 3;
                     statusText.textContent = "\"The exit is running away...\"";
                     boredom += 5;
                }
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp') moveCharacter(-1, 0);
            if (e.key === 'ArrowDown') moveCharacter(1, 0);
            if (e.key === 'ArrowLeft') moveCharacter(0, -1);
            if (e.key === 'ArrowRight') moveCharacter(0, 1);
        });

        // Touch Controls
        let touchStartX = 0;
        let touchStartY = 0;

        document.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, {passive: false});

        // Prevent pull-to-refresh when user pulls down at top of page (mobile Safari / others)
        function onTouchMovePrevent(e) {
            if (!gameActive) return;
            const touch = e.changedTouches ? e.changedTouches[0] : null;
            if (!touch) return;
            const diffY = touch.screenY - touchStartY;
            if (window.scrollY === 0 && diffY > 0) {
                // The user is pulling down at the top ‚Äî prevent the browser's refresh
                e.preventDefault();
            }
        }
        document.addEventListener('touchmove', onTouchMovePrevent, {passive: false});

        document.addEventListener('touchend', (e) => {
            if (!gameActive) return;
            let touchEndX = e.changedTouches[0].screenX;
            let touchEndY = e.changedTouches[0].screenY;
            
            let diffX = touchEndX - touchStartX;
            let diffY = touchEndY - touchStartY;
            
            if (Math.abs(diffX) > Math.abs(diffY)) {
                if (Math.abs(diffX) > 30) { 
                    if (diffX > 0) moveCharacter(0, 1);
                    else moveCharacter(0, -1);
                }
            } else {
                if (Math.abs(diffY) > 30) {
                    if (diffY > 0) moveCharacter(1, 0);
                    else moveCharacter(-1, 0);
                }
            }
        }, {passive: false});

        setInterval(() => {
            if (gameActive && Date.now() - lastMoveTime > 500) {
                boredom = Math.min(100, boredom + 1);
                updateStatus();
                if (boredom >= 100) {
                    triggerGameOver();
                }
            }
        }, 1000);

        drawMaze();
        updateStatus();

    </script>

</body>
</html>